# SPDX-License-Identifier: Apache-2.0
#
# Copyright 2025 Yingwei Zheng
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file was generated by GitHub Copilot.

import os
import time
import requests
from typing import List, Dict, Any

class DaemonError(Exception):
    def __init__(self, reason):
        super().__init__(reason)
        self.reason = reason


def create_fuzz_task(cmd: str, pr_html_url: str):
    """Create a fuzzing issue in the corresponding repo based on the command and PR url."""
    import re

    m = re.search(r"/pull/(\d+)", pr_html_url)
    if not m:
        raise DaemonError("[WARN] Cannot extract PR number from url.")
    pr_number = m.group(1)
    issue_title = f"Fuzz PR{pr_number}"
    issue_body = pr_html_url
    if "csmith-quick-fuzz" in cmd:
        labels = ["quickfuzz"]
        repo = "llvm-fuzz-service"
    elif "csmith-fuzz" in cmd:
        labels = ["fuzz2h"]
        repo = "llvm-fuzz-service"
    else:  # mfuzz
        labels = ["quickfuzz"]
        repo = "llvm-mutation-based-fuzz-service"
    token = os.environ.get("GITHUB_TOKEN")
    if not token:
        raise DaemonError("[WARN] GITHUB_TOKEN not set, cannot create issue.")
    url = f"https://api.github.com/repos/dtcxzyw/{repo}/issues"
    headers = {
        "Authorization": f"Bearer {token}",
        "Accept": "application/vnd.github+json",
    }
    data = {"title": issue_title, "body": issue_body, "labels": labels}
    resp = requests.post(url, headers=headers, json=data)
    if resp.status_code != 201:
        raise DaemonError(
            f"[WARN] Failed to create issue: {resp.status_code} {resp.text}"
        )
    else:
        print(f"[INFO] Issue created for PR {pr_number} in {repo}")


def get_github_token() -> str:
    token = os.environ.get("GITHUB_TOKEN")
    if not token:
        raise DaemonError("GITHUB_TOKEN environment variable not set.")
    return token


def get_latest_notifications(since: str = None, last_modified: str = None):
    url = "https://api.github.com/notifications"
    headers = {
        "Authorization": f"Bearer {get_github_token()}",
        "Accept": "application/vnd.github+json",
    }
    params = {"participating": "true"}
    if since:
        params["since"] = since
    if last_modified:
        headers["If-Modified-Since"] = last_modified
    response = requests.get(url, headers=headers, params=params)
    # X-Poll-Interval: how many seconds to wait before next poll
    poll_interval = int(response.headers.get("X-Poll-Interval", 60))
    new_last_modified = response.headers.get("Last-Modified")
    if response.status_code == 304:
        # Not modified
        return [], poll_interval, new_last_modified
    response.raise_for_status()
    return response.json(), poll_interval, new_last_modified


def get_pr_comments(pr_url: str) -> List[Dict[str, Any]]:
    # pr_url: e.g. https://api.github.com/repos/owner/repo/issues/123
    headers = {
        "Authorization": f"Bearer {get_github_token()}",
        "Accept": "application/vnd.github+json",
    }
    comments_url = pr_url + "/comments"
    response = requests.get(comments_url, headers=headers)
    response.raise_for_status()
    return response.json()


def handle_comment(pr_html_url: str, comment_author: str, comment_body: str):
    print(
        f"[AT] PR: {pr_html_url}\nAuthor: {comment_author}\nContent: {comment_body}\n"
    )
    # Ignore comments made by zyw-bot itself
    if comment_author == "zyw-bot":
        return
    # Check if the comment author is a member of the llvm organization using a separate token
    org = "llvm"
    user_url = f"https://api.github.com/orgs/{org}/members/{comment_author}"
    membership_token = os.environ.get("GITHUB_MEMBERSHIP_TOKEN")
    if not membership_token:
        raise DaemonError(
            "[WARN] GITHUB_MEMBERSHIP_TOKEN not set, skip membership check."
        )
    headers = {
        "Authorization": f"Bearer {membership_token}",
        "Accept": "application/vnd.github+json",
    }
    resp = requests.get(user_url, headers=headers)
    if resp.status_code != 204:
        # Not a member
        raise DaemonError("The commenter is not an LLVM member.")
    # Remove leading/trailing whitespace and newlines from comment_body
    comment_body = comment_body.strip()
    import re

    match = re.search(r"@zyw-bot (csmith-quick-fuzz|csmith-fuzz|mfuzz)\b", comment_body)
    if not match:
        raise DaemonError("""Invalid command. Available commands:
[AT]zyw-bot csmith-quick-fuzz run stress testing on a small, distilled corpus. (~4min)
[AT]zyw-bot csmith-fuzz       run stress testing on a larger corpus generated by csmith. (~100min)
[AT]zyw-bot mfuzz             run mutation-based testing with Alive2. (~5min)
                              Please make sure that this patch has enough triggering tests.
""")
    cmd = match.group(0)
    # If the command is csmith-quick-fuzz, csmith-fuzz, or mfuzz, create an issue in the corresponding repo
    if "csmith-quick-fuzz" in cmd or "csmith-fuzz" in cmd or "mfuzz" in cmd:
        create_fuzz_task(cmd, pr_html_url)

def post_comment(pr_html_url: str, message: str):
    """Post a comment to the PR for feedback."""
    import re
    m = re.search(r"github.com/([^/]+/[^/]+)/pull/(\d+)", pr_html_url)
    if not m:
        print(f"[WARN] Cannot extract repo/pr from url for comment: {pr_html_url}")
        return
    repo = m.group(1)
    pr_number = m.group(2)
    token = os.environ.get("GITHUB_TOKEN")
    if not token:
        print("[WARN] GITHUB_TOKEN not set, cannot post comment.")
        return
    url = f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments"
    headers = {
        "Authorization": f"Bearer {token}",
        "Accept": "application/vnd.github+json",
    }
    data = {"body": message}
    resp = requests.post(url, headers=headers, json=data)
    if resp.status_code != 201:
        print(f"[WARN] Failed to post comment: {resp.status_code} {resp.text}")
    else:
        print(f"[INFO] Comment posted to PR {pr_number}")

visited_comment = set()

def process_notifications(last_checked: str = None, last_modified: str = None):
    global visited_comment
    notifications, poll_interval, new_last_modified = get_latest_notifications(
        since=last_checked, last_modified=last_modified
    )
    for n in notifications:
        if n.get("reason") != "mention":
            continue
        repo = n.get("repository", {})
        if repo.get("full_name") != "llvm/llvm-project":
            continue
        subject = n.get("subject", {})
        if subject.get("type") != "PullRequest":
            continue
        pr_html_url = (
            subject.get("url", "")
            .replace("api.github.com/repos", "github.com")
            .replace("/pulls/", "/pull/")
        )
        latest_comment_url = subject.get("latest_comment_url")
        if not latest_comment_url or latest_comment_url in visited_comment:
            continue
        visited_comment.add(latest_comment_url)
        headers = {
            "Authorization": f"Bearer {get_github_token()}",
            "Accept": "application/vnd.github+json",
        }
        resp = requests.get(latest_comment_url, headers=headers)
        if resp.status_code != 200:
            print(
                f"[WARN] Failed to fetch latest comment: {resp.status_code} {resp.text}"
            )
            continue
        c = resp.json()
        body = c.get("body", "")
        if "@zyw-bot" not in body:
            continue
        author = c.get("user", {}).get("login", "")
        try:
            handle_comment(pr_html_url, author, body)
        except DaemonError as e:
            post_comment(pr_html_url, e.reason)
    return poll_interval, new_last_modified


def main():
    last_checked = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    last_modified = None
    poll_interval = 60
    while True:
        try:
            poll_interval, last_modified = process_notifications(
                last_checked, last_modified
            )
            last_checked = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
        except Exception as e:
            print(f"Error: {e}")
        time.sleep(poll_interval)

if __name__ == "__main__":
    main()
